[["index.html", "Tésis Capitulo 1 Introducción", " Tésis Nicolás Fernández 2023-08-26 Capitulo 1 Introducción En este cuaderno se va a ir armando. "],["convertir-hora-local-a-solar.html", "Capitulo 2 Convertir hora local a solar 2.1 Preparación 2.2 Ecuación del tiempo 2.3 Hora local y hora solar 2.4 Conviertiendo 2.5 Función de R para calcular hora solar verdadera 2.6 Probando con datos reales", " Capitulo 2 Convertir hora local a solar Se va a utilizar el archivo “planilla_general.RData” descargada desde el drive del laboratorio. Primero se carga, se modifican los nombres de algunas columnas y se seleccionan solo las que se van a utilizar. library(tidyverse) load(&quot;datos/planilla_general.RData&quot;) datos &lt;- data %&gt;% filter(type == &quot;Mammal&quot;) %&gt;% select(sitio = site, sistema=station, camara = camera, datetime, grupo=group, sp=species) paged_table(head(datos)) También se necesitan los datos de las cámaras: Longitud y latitud Se procede a cargar esos datos: datos_camaras &lt;- read.csv(&quot;datos/info_dispositivos.csv&quot;) %&gt;% filter(tipo_dispositivo == &quot;camera&quot;) %&gt;% select(sitio, camara = id_dispositivo, long, lat) 2.1 Preparación Ahora, se va a elegir el AP Cabo Polonio para poner a punto el código. De esta forma, una vez esten todos los datos se pueda correr el código y generar los mismos cálculos. Siempre y cuando el formato de los datos sea el mismo. datos &lt;- datos %&gt;% filter(sitio ==&quot;CP&quot;) datos_camaras &lt;- datos_camaras %&gt;% filter(sitio == &quot;CP&quot;) %&gt;% select(camara, long, lat) datos &lt;- datos %&gt;% left_join(datos_camaras, by = join_by(camara)) 2.2 Ecuación del tiempo El movimiento aparente del Sol no es uniforme y la duración del día solar no es constante a lo largo del año. La diferencia entre el movimiento aparente del Sol y el movimiento medio se denomina ecuación del tiempo. La expresión tomada de General Solar Position calculations (NOAA) nos da la ecuación del tiempo en minutos: \\[ \\Delta t = 229.18 \\cdot (0.0.000075 + 0.001868 \\cdot \\cos{x} - 0.032077 \\cdot \\sin{x} - 0.014615 \\cdot \\cos{2x} - 0.040849 \\sin{2x}) \\] Donde \\(x\\) se define en función del número de día \\(N\\) y la hora \\(h\\) \\[ x=\\frac{2 \\pi}{365}\\left (N-1+ \\frac{h-12}{24} \\right ) \\] 2.3 Hora local y hora solar La hora solar se fundamenta en que la Tierra da una vuelta completa en 24 horas y que a las 12:00 h el Sol apunta exactamente hacia el sur. La hora solar verdadera se calcula mediante las dos ecuaciones siguientes: \\[ \\textit{time_offset} = eq_{time}-4\\cdot \\textit{longitude}+60\\cdot \\textit{timezone} \\] Donde: \\(eq_{Time}\\) es \\(\\Delta T\\), la ecuación del tiempo. \\(\\textit{longitude}\\) es la longitud del lugar en grados. \\(\\textit{timezone}\\) es el tiempo en horas desde UTC. En nuestro caso sería GMT-3, por lo que el valor sería -3. Finalmente, la hora solar verdadera tst, en minutos, se obtiene mediante la siguiente ecuación: \\[ tst = hr \\cdot 60 + min + \\frac{seg}{60}+\\textit{time_offset} \\] 2.4 Conviertiendo Datos de ejemplo: # Obtiene los datos para el presente. hoy = now() N = yday(hoy) # Días del año. h = hour(hoy) mm = minute(hoy) ss = second(hoy) longitude = -56.22515783536338 timezone = -3 Ecuación del tiempo, utilizando el x para los datos. x=2*pi*(N-1-(h-12)/24)/365 eqtime=229.18*(0.000075+0.001868*cos(x)-0.032077*sin(x)-0.014615*cos(2*x)-0.040849*sin(2*x)) Diferencia de uso horario (time offset) time_offset=eqtime-4*longitude+60*timezone Hora solar verdadera (tst) tst=h*60+mm+ss/60-time_offset print(desplazamiento_horario) Este resultado es en minutos, si lo convertimos: hours_ &lt;- tst/60 minutes_&lt;- (hours_-floor(hours_))*60 seconds_ = (minutes_ -floor(minutes_))*60 paste0(floor(hours_),&quot;:&quot;,floor(minutes_),&quot;:&quot;,floor(seconds_)) ## [1] &quot;21:22:42&quot; 2.5 Función de R para calcular hora solar verdadera horasolar &lt;- function(datetime, longitude, timezone) { date_structure &lt;- as.POSIXlt(as.POSIXct(datetime), tz = timezone) timezone_value &lt;- date_structure$gmtoff / 3600 N = yday(datetime) # Días del año. h = hour(datetime) mm = minute(datetime) ss = second(datetime) x=2*pi*(N-1-(h-12)/24)/365 eqtime=229.18*(0.000075+0.001868*cos(x)-0.032077*sin(x)-0.014615*cos(2*x)-0.040849*sin(2*x)) time_offset=eqtime-4*longitude+60*timezone_value tst=h*60+mm+ss/60-time_offset hours_ &lt;- tst/60 minutes_&lt;- (hours_-floor(hours_))*60 seconds_ = (minutes_ -floor(minutes_))*60 # Para formatear hours_text &lt;- abs(floor(hours_)) minutes_text &lt;- abs(floor(minutes_)) seconds_text &lt;- abs(floor(seconds_)) hours_text &lt;- ifelse(nchar(hours_text) &lt; 2, paste0(&quot;0&quot;, hours_text), hours_text) minutes_text &lt;- ifelse(nchar(minutes_text) &lt; 2, paste0(&quot;0&quot;, minutes_text), minutes_text) seconds_text &lt;- ifelse(nchar(seconds_text) &lt; 2, paste0(&quot;0&quot;, seconds_text), seconds_text) resultado &lt;- paste0(as.character(date(datetime)), &quot; &quot;,hours_text, &quot;:&quot;, minutes_text, &quot;:&quot;, seconds_text) %&gt;% as.POSIXct(., tz = timezone) return(resultado) } 2.6 Probando con datos reales Entonces, ahora apliquemos esta función al conjunto de datos. Para recordar como era la estructura de datos: datos %&gt;% head() %&gt;% paged_table() Apliquemos la función: datos %&gt;% mutate(hora_solar = horasolar(datetime=datetime, longitude=long, timezone=&quot;America/Montevideo&quot;)) %&gt;% select(sitio, camara, datetime, hora_solar, sp) %&gt;% head() %&gt;% paged_table() "],["detectando-actividad.html", "Capitulo 3 Detectando actividad 3.1 Utilizando suncalc 3.2 Etapa del día según hora solar 3.3 Jugando con los datos", " Capitulo 3 Detectando actividad Se intenta agregar una columna que marque el registro como nocturno/crepuscular/diurno, en base: Diurnos: Registros entre el final del amanecer y el inicio del atardecer Nocturnos: Entre el final del atardecer y el inicio del amanecer se consideraron registros nocturnos Crepuscular: Entre el inicio del atardecer y el final del atardecer, y entre el inicio y el final del amanecer. El set de datos que voy a utilizar va a ser el mismo con el que se viene ejemplificando, notar que ya tiene la hora solar incluida. 3.1 Utilizando suncalc Registros entre el final del amanecer y el inicio del atardecer library(suncalc) ######### IMPORTANTE DATOS ESTABAN EN UTC. ########### datos$datetime &lt;- force_tz(datos$datetime, tz=&quot;America/Montevideo&quot;) # Ahora si obtengo sun_times datos &lt;- datos %&gt;% mutate(date = date(datetime)) %&gt;% rename(lon = long) sun_times &lt;- getSunlightTimes(data=datos, tz = &quot;America/Montevideo&quot;) # Amanecer ## Comienzo datos$sunriseStart &lt;- sun_times$sunrise ## Final datos$sunriseEnd &lt;- sun_times$sunriseEnd # Atardecer ## Inicio datos$sunsetStart &lt;- sun_times$sunsetStart ## Final datos$sunsetEnd &lt;- sun_times$dusk Ahora se puede detectar si un registro es diurno, crepuscular o nocturno, siguiendo el método que hizo Cravino et al. 3.2 Etapa del día según hora solar La idea es poder identificar si un registro cae en alguna de las siguientes categorías, utilizando la hora solar: Los datos con los que se van a trabajar son los siguientes: Primero hay que transformar esa hora solar en valores de angulos en un circulo. Utilizando radianes. 3.2.1 Hora solar a decimal y radianes # Calcula el valor decimal de la hora datos &lt;- datos %&gt;% mutate(hora_decimal = hour(hora_solar)+ minute(hora_solar)/60 + second(hora_solar)/3600, # Se extrae la hora en valores decimales. hora_radianes = hora_decimal * ((2 * pi)/24)) # También se almacena en radianes plot(circular(prueba$hora_decimal), units = &quot;hours&quot;, template=&quot;clock24&quot;) plot(circular(prueba$hora_radianes), units = &quot;radians&quot;) Con esto se puede delimitar las categorias de nocturno, diruno y crepuscular facilmente: datos &lt;- datos %&gt;% mutate(etapa_dia = if_else(hora_decimal &lt;= 4 &amp; hora_decimal &gt;= 0 | hora_decimal &gt;= 20, &quot;Nocturno&quot;, if_else(hora_decimal &gt;= 8 &amp; hora_decimal &lt;= 16, &quot;Diurno&quot;, &quot;Crepuscular&quot;))) 3.3 Jugando con los datos Ahora, por ej., se puede calcular cuantos registros de axis son nocturnos, diurnos o crepusculares en Cabo Polonio. datos %&gt;% filter(sp == &quot;Aaxi&quot;) %&gt;% group_by(etapa_dia) %&gt;% summarize(&quot;Cantidad de registros de Axis&quot; = n()) ## # A tibble: 3 × 2 ## etapa_dia `Cantidad de registros de Axis` ## &lt;chr&gt; &lt;int&gt; ## 1 Crepuscular 90 ## 2 Diurno 86 ## 3 Nocturno 55 "],["kernels-de-actividad.html", "Capitulo 4 Kernels de actividad", " Capitulo 4 Kernels de actividad Voy a utilizar el paquete overlap para realizar los graficos de kernel. Los datos utilizados continuan siendo los mismos: "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
